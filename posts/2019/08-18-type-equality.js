/**
 * Script for the MongoDB Shell.
 * @author Andrew Jarombek
 * @since 8/18/2019
 */

connection = new Mongo();
db = connection.getDB("jarombekcom");

preview = [
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In this article I'm revisiting the concept of type equality.  Type equality is a topic that software engineers  learn early on in their careers.  Similar to any other profession, it's beneficial to go back to the basics for practice.  Professional basketball players practice layups before each game. Professional programmers should work at the basics as well.  I spent this past week re-learning type equality in 13 different languages.  In the process I've reaffirmed my knowledge and gained new insights.  The rest of this article discusses my findings. ",
                "children":null
            }
        ]
    },
    {
        "el":"h5",
        "attributes":{
            "title":"The Different Forms of Type Equality"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"The Different Forms of Type Equality",
                "children":null
            }
        ]
    }
];

content = [
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In this article I'm revisiting the concept of type equality.  Type equality is a topic that software engineers  learn early on in their careers.  Similar to any other profession, it's beneficial to go back to the basics for practice.  Professional basketball players practice layups before each game. Professional programmers should work at the basics as well.  I spent this past week re-learning type equality in 13 different languages.  In the process I've reaffirmed my knowledge and gained new insights.  The rest of this article discusses my findings. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"The Different Forms of Type Equality"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"The Different Forms of Type Equality",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Each programming language has its own intricacies in regards to analysing types for equality. ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/jul-15-2018-groovy-optional-typing#type"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Types",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" are the blueprints for values in programming languages.  Types define the characteristics of a value and differentiates a value from other types",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"1",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Equality is a test to see if two values are equal.  There are two main forms of equality - reference equality and value equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"comparisontable",
        "attributes":{
            "title":"Forms of Equality"
        },
        "value":null,
        "children":[
            {
                "el":"comparisontableentry",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"h5",
                        "attributes":{
                            "classname":"jarombek-cte-title"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":" Reference Equality ",
                                "children":null
                            }
                        ]
                    },
                    {
                        "el":"div",
                        "attributes":{
                            "classname":"jarombek-cte-body"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"p",
                                "attributes":null,
                                "value":null,
                                "children":[
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" Tests for reference equality check to see if two variables, primitives, or objects refer to the same space in memory.  When two variables are referentially equal, altering the value of one impacts the other since they refer to the same bytes in memory.  For example, ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"var a = \"value\"",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" and ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"var b = a",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" results in two variables   that point to the same memory location in many languages. ",
                                        "children":null
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "el":"comparisontableentry",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"h5",
                        "attributes":{
                            "classname":"jarombek-cte-title"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":" Value Equality ",
                                "children":null
                            }
                        ]
                    },
                    {
                        "el":"div",
                        "attributes":{
                            "classname":"jarombek-cte-body"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"p",
                                "attributes":null,
                                "value":null,
                                "children":[
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" Tests for value equality check to see if two variables, primitives, or objects are logically the same. For example, two integers containing the value ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"2",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" are deemed  equal in value, since ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"2 = 2",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":".  Another example is two objects ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"a",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" and ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"b",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" where the properties in ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"a",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" have the same values assigned to them as the properties in ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"b",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":".  These two objects would pass a value equality check. ",
                                        "children":null
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In many languages value equality is dependent on the two values conforming to the same type.  However, some languages lift this restriction in certain circumstances. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Languages that allow values of different types to be equal are generally considered loosely typed.  Languages where it's impossible or very rare for values of different types to be equal are generally considered strongly typed.  Loosely typed and strongly typed languages should not be confused for ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/jul-15-2018-groovy-optional-typing#dynamic-&-static-typing"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"dynamically and statically typed languages",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"comparisontable",
        "attributes":{
            "title":"Type Rules"
        },
        "value":null,
        "children":[
            {
                "el":"comparisontableentry",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"h5",
                        "attributes":{
                            "classname":"jarombek-cte-title"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":" Loosely Typed ",
                                "children":null
                            }
                        ]
                    },
                    {
                        "el":"div",
                        "attributes":{
                            "classname":"jarombek-cte-body"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"p",
                                "attributes":null,
                                "value":null,
                                "children":[
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" A language that is loosely typed (weakly typed) is one where type rules are not as strict.  In a loosely typed language types can often be converted to other types implicitly.  This is known as implicit type coercion, since a type can be coerced to another type.  For example, in PHP ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"2 == '2'",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" returns ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"true",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" because the string ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"'2'",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" is implicitly converted to a number before the type equality check is made.  Languages such as JavaScript, PHP, and PowerShell are generally considered loosely typed languages.  However, there is no clear boundary between a loosely typed language and a strongly typed language.  It's mostly up to personal interpretation which category the language belongs in. ",
                                        "children":null
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "el":"comparisontableentry",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"h5",
                        "attributes":{
                            "classname":"jarombek-cte-title"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":" Strongly Typed ",
                                "children":null
                            }
                        ]
                    },
                    {
                        "el":"div",
                        "attributes":{
                            "classname":"jarombek-cte-body"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"p",
                                "attributes":null,
                                "value":null,
                                "children":[
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" A language that is strongly typed has very strict type rules.  In order for a type to be converted to another type, an explicit conversion mechanism must be visible in the code.  For example, Java is a strongly typed language where explicit casts are used to convert from one type to another, such as ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"double two = 2.0",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" and ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"int twoInt = (int) two;",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":".  However, there are still a few cases in Java where implicit type coercion occurs, such as converting an ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"int",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" to a ",
                                        "children":null
                                    },
                                    {
                                        "el":"code",
                                        "attributes":{
                                            "class":"jarombek-inline-code"
                                        },
                                        "value":"double",
                                        "children":null
                                    },
                                    {
                                        "el":"#text",
                                        "attributes":null,
                                        "value":" or boxing and un-boxing primitives.  Languages such as C, Java, and Python are generally considered strongly typed.  Just like loosely typed languages, there is no explicit rule for whether or not a language is strongly typed.  It's mostly up to personal interpretation of the language. ",
                                        "children":null
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Now let's explore equality in the programming languages I use.  Look out for the different ways each language handles reference and value equality.  In terms of value equality, watch out for loosely typed languages that enable type coercion.  I'll start with my main three languages - Java, JavaScript, and Python.  Then I'll run through the remaining ten languages in alphabetical order. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Java"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Java",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=java&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Java",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" has two different categories of types - primitives and objects.  Primitive types are checked for value equality with the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator.  Object types are checked for reference equality with the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator and value equality with the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method found in the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Object",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" class. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator tests the values in two variables memory locations for equality.  Primitive types hold their values directly in their assigned memory space.  Therefore, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests for value equality with primitives. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Java"
        },
        "value":"int five = 5;\nint six = 6;\nassert five != six;\n\nint fiveAgain = 5;\nassert five == fiveAgain;\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" There is no way to test reference equality with primitives.  Primitives also can't use the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method since they aren't objects and can't have methods. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The following code demonstrates how ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"String",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" objects are tested for equality.  String literals are unique because  Java caches them in the same memory location if they have equal values.  As you will soon see, many other languages use this optimization for strings as well. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Java"
        },
        "value":"String day = \"Saturday the 27th\";\nString dayAgain = \"Saturday the 27th\";\nString dayAgainAgain = new String(\"Saturday the 27th\");\n\n// This is a unique case.  Java caches string literals (not created with a constructor) so\n// that they reference the same underlying object in memory.\nassert day == dayAgain;\n\n// When Strings are created with a constructor (like dayAgainAgain), they are not cached and reference\n// a new underlying object.\nassert day != dayAgainAgain;\n\n// equals() performs value comparison as expected.\nassert day.equals(dayAgain);\nassert day.equals(dayAgainAgain);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" However, for most objects ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests for reference equality and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests for value equality.  I created a custom ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Yarn",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" class to demonstrate how object equality works.  For value equality to work properly, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Yarn",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" overrides the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method from ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Object",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Java"
        },
        "value":"public class Yarn {\n\n  private String fiber;\n  private String color;\n  private int yards;\n\n  /**\n   * Private constructor for a new ball of yarn.  Can only be invoked by the static factory method.\n   * @param fiber The fiber that the yarn is made of.\n   * @param color The visual color of the yarn.\n   * @param yards The length of the yarn in yards.\n   */\n  private Yarn(String fiber, String color, int yards) {\n    this.fiber = fiber;\n    this.color = color;\n    this.yards = yards;\n  }\n\n  /**\n   * Static factory method for constructing a new ball of yarn.  Requires that a value be assigned for each\n   * instance variable, although it does accept null values.\n   * @return A new Yarn object.\n   */\n  static Yarn create(String fiber, String color, int yards) {\n    return new Yarn(fiber, color, yards);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this)\n      return true;\n    if (!(obj instanceof Yarn))\n      return false;\n    var otherYarn = (Yarn) obj;\n    return Objects.equals(fiber, otherYarn.fiber)\n      && Objects.equals(color, otherYarn.color)\n      && yards == otherYarn.yards;\n  }\n}\n",
        "children":null
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Java"
        },
        "value":"var yarn1 = Yarn.create(\"Polyester\", \"Pitter Patter\", 210);\nvar yarn2 = yarn1;\nvar yarn3 = Yarn.create(\"Polyester\", \"Pitter Patter\", 210);\nvar yarn4 = Yarn.create(\"Unknown\", \"Vanilla\", 70);\n\nassert yarn1 == yarn2;\nassert yarn1.equals(yarn2);\n\nassert yarn2 != yarn3;\nassert yarn2.equals(yarn3);\n\nassert yarn3 != yarn4;\nassert !yarn3.equals(yarn4);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Variables ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"yarn1",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"yarn2",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" are the only ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Yarn",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" instances that pass reference and value equality tests. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" While Java is generally a strongly typed language, there are a few occasions where type coercion occurs with the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator.  This is usually due to boxing and un-boxing primitives along with comparing numeric primitives",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"2",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Here are a few examples: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Java"
        },
        "value":"double two = 2.0;\nint twoInt = (int) two;\n\n// This comparison is successful even though two is of type 'double' and twoInt is of type 'int'.\nassert two == twoInt;\n\n// This comparison is successful because Integer is coerced (un-boxed) to primitive type int.  new Integer() is now deprecated.\nassert 2 == new Integer(2);\n\nInteger twoInteger = 2;\nassert twoInt == twoInteger;\n\n// In most cases, comparing two values of different types fails at compile time.\n// assert 2 == \"2\";\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"JavaScript"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"JavaScript",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=javascript&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"JavaScript",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" has two operators that perform equality checks - ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"===",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". When working with primitive types, both operators test value equality.  When working with object types, both operators test reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" There isn't much debate that JavaScript is a loosely typed programming language.  When working with primitives, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" enables implicit type coercion during the comparison.  On the other hand, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"===",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" prohibits implicit type coercion.  For example, when comparing a string and a number using ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", the string is converted to a numeric type before the comparison occurs. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JavaScript"
        },
        "value":"assert(2 == \"2\");\nassert(\"2\" == 2);\n\n// This is the same as:\nassert(2 === Number(\"2\"));\n\n// If a number is compared to a string using !==, no type coercion occurs.\nassert(2 !== \"2\");\nassert(\"2\" !== 2);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Because JavaScript contains a lot of implicit type coercion, many developers argue that you shouldn't use ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" on primitives.  Here are some examples of the confusing consequences of implicit type coercion: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JavaScript"
        },
        "value":"\n// This first converts 'true' to its number equivalent, which is 1.  Then it converts \"0\" to a\n// number.  Then it compares 1 === 0, which is false.\nassert(true != \"0\");\n\n// This first converts 'false' to its number equivalent, which is 0.  Then it converts \"0\" to a\n// number.  Then it compares 0 === 0, which is true.\nassert(false == \"0\");\n\n// 'true' converts to 1, \"1\" converts to 1.  The expression 1 === 1 is true.\nassert(true == \"1\");\n\n// 'true' converts to 1, \"2\" converts to 2.  The expression 1 === 2 is false.\nassert(true != \"2\");\n\n// Since null and undefined are both falsey, comparing them with == returns true.\nassert(undefined == null);\nassert(null == undefined);\n\n// But with === they return false.\nassert(undefined !== null);\nassert(null !== undefined);\n\n// However, null and undefined are not equal to any other types, even if their values are falsey\nassert(null != \"\");\nassert(null !== \"\");\nassert(null != 0);\nassert(null !== 0);\nassert(null != false);\nassert(null !== false);\n\n// When an object type is compared to a primitive type with ==, the object\n// is first coerced into a primitive value.\n\n// An array is a type of object.\nassert([10] == 10);\nassert([10] == \"10\");\nassert([10] !== \"10\");\n\n// A function is also a type of object.\nassert(() => \"hello\" == \"hello\");\nassert(() => \"100\" == \"100\");\nassert(() => \"100\" == 100);\nassert(() => \"100\" !== 100);\n\n// Objects containing a property with a certain value aren't coerced into that value.\nassert({value: 1} != 1);\n\n// However, objects created by passing a primitive value into an object constructor\n// are coerced to that value.\nassert(new Object(1) == 1);\nassert(new Object(1) !== 1);\n\n// You can monkey-patch prototype functions to create strange equality behavior.\nconst twentyTwo = new Number(22);\n\nassert(23 != 24);\nassert(twentyTwo != 23); // 22 != 23 as expected\n\nNumber.prototype.valueOf = () => {\n  return 23;\n};\n\nassert(23 != 24);\nassert(twentyTwo == 23); // 22 == 23 unexpectedly due to valueOf() monkey patch.\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" When testing object types for equality, the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"===",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operators are much more predictable.  They both test objects for reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JavaScript"
        },
        "value":"assert({} != {});\nassert({} !== {});\n\n// Remember that arrays and functions are also objects in JavaScript.\nassert([] != []);\nassert([] !== []);\nassert((() => {}) != (() => {}));\nassert((() => {}) !== (() => {}));\n\nconst emptyObj1 = {};\n\n// emptyObj2 references the same object in memory as emptyObj1.\nconst emptyObj2 = emptyObj1;\n\n// emptyObj3 creates a new object with emptyObj1 as its prototype.\nconst emptyObj3 = Object.create(emptyObj1);\n\n// emptyObj4 uses emptyObj1 as a base object and copies the empty object into the base object.\nconst emptyObj4 = Object.assign(emptyObj1, {});\n\nassert(emptyObj1 == emptyObj2);\nassert(emptyObj1 === emptyObj2);\n\nassert(emptyObj1 != emptyObj3);\nassert(emptyObj1 !== emptyObj3);\n\nassert(emptyObj1 == emptyObj4);\nassert(emptyObj1 === emptyObj4);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" If we want to test objects for value equality, a custom function must be created.  The following function tests objects for value equality one level deep",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"3",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JavaScript"
        },
        "value":"/**\n * Test for value equality on two objects.  NOTE: nested objects are tested for reference equality.\n * @param a the first object to compare for equality.\n * @param b the second object to compare for equality.\n * @return {boolean} {@code true} if the objects (un-nested) property values are equal,\n * {@code false} otherwise.\n */\nconst equals = (a, b) => {\n  const aProps = Object.getOwnPropertyNames(a);\n  const bProps = Object.getOwnPropertyNames(b);\n\n  if (aProps.length !== bProps.length) {\n    return false;\n  }\n\n  for (let i = 0; i < aProps.length; i++) {\n    const propName = aProps[i];\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// Prove that equals() tests for value equality on object properties.\nassert(equals({}, {}));\nassert(equals({first: 'andy', last: 'jarombek'}, {last: 'jarombek', first: 'andy'}));\n\n// This still won't work for nested objects.\nassert(\n  !equals(\n    {type: 'walk', stats: {minutes: 76, seconds: 40}},\n    {type: 'walk', stats: {minutes: 76, seconds: 40}}\n  )\n);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The following function tests arrays (which are also objects in JavaScript) for value equality",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"4",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JavaScript"
        },
        "value":"/**\n * Test for value equality on two arrays.  NOTE: object values in the array are tested for\n * reference equality.\n * @param array1 The first array to test for equality.\n * @param array2 The second array to test for equality.\n * @return {boolean} {@code true} if the arrays (un-nested) values are equal,\n * {@code false} otherwise.\n */\nconst arrayEquals = (array1, array2) => {\n  if (array1.length !== array2.length) return false;\n\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) return false;\n  }\n\n  return true;\n};\n\n// Prove that arrayEquals() tests for value equality on array items.\nassert(arrayEquals([], []));\nassert(arrayEquals([1, \"2\", true], [1, \"2\", true]));\n\n// ...however it still tests for reference equality when array items are objects.\nassert(!arrayEquals([{}], [{}]));\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Python"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Python",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=python&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Python",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" has two ways to test for equality - the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator and the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"is",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" statement.  Value equality is tested with ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and reference equality is tested with ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"is",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Python equality is easier to reason about because all types are objects.  Python is also strongly typed, so there is no implicit type coercion when testing equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"# Value equality is tested with the == operator.\nassert 1 == 1\nassert \"andy\" == \"andy\"\n\n# Python's == operator doesn't coerce types.\nassert \"1\" != 1\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Similar to Java, Python caches string literals in the same memory location, causing the results of ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"is",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is be the same. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"# Both these strings pass value and reference equality tests.\nfirst = \"Andy\"\nfirstAgain = \"Andy\"\n\n# Both these strings pass value and reference equality tests.\nforever = \"rock Forever 21 but just turned thirty\"\nforeverAgain = str(\"rock Forever 21 but just turned thirty\")\n\n# These strings pass value equality tests but not reference equality tests.\ndesc = \"Andrew Jarombek is a big fan of cats 🐱\"\ndescAgain = \"Andrew Jarombek is a big fan of cats \" + \"🐱\"\n\nassert first == firstAgain\nassert forever == foreverAgain\nassert desc == descAgain\n\n# Reference equality is tested with the 'is' keyword.\n# Similar to Java, Python caches strings in certain implementations.  Be careful, two strings that pass the value\n# equality test may not pass the reference equality test.\nassert first is firstAgain\nassert forever is foreverAgain\nassert desc is not descAgain\n\n# Every Python type is an object. Each object in Python is assigned a unique identifier.  You can think this unique\n# identifier as the memory location of the object.\nassert id(first) == id(firstAgain)\nassert id(forever) == id(foreverAgain)\nassert id(desc) != id(descAgain)\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" I created a custom ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Yarn",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" class to demonstrate the normal behavior of ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"is",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". Python provides a built in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"__eq__",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method that classes can override. This method impacts the behavior of the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator for testing value equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"class Yarn:\n  \"\"\"\n  Class representing a ball of yarn for knitting.\n  \"\"\"\n\n  def __init__(self, fiber: str, color: str, yards: int):\n    \"\"\"\n    Construct a new yarn object.  Yarn is a plain Python object with three properties, all of which should be\n    assigned values upon construction.\n    :param fiber: The fiber that the yarn is made of.\n    :param color: The visual color of the yarn.\n    :param yards: The length of the yarn in yards.\n    \"\"\"\n    self.fiber = fiber\n    self.color = color\n    self.yards = yards\n\n  def __eq__(self, other):\n    \"\"\"\n    Implement the built in __eq__ function to test for value equality between two Yarn objects.  Return\n    NotImplemented if a Yarn object is compared to a different object.  By default __neq__ negates the result of\n    __eq__, so I don't need to explicitly implement it.\n    :param other: An object to compare to this Yarn object.\n    :return: true if the two balls of yarn are equal, false otherwise.  NotImplemented if the second object isn't\n    an instance of Yarn.\n    \"\"\"\n    if isinstance(other, Yarn):\n      return self.fiber == other.fiber and self.color == other.color and self.yards == other.yards\n    else:\n      return NotImplemented\n\n\n# Create balls of yarn to test for equality.\nyarn1 = Yarn(fiber='Polyester', color='Pitter Patter', yards=210)\nyarn2 = yarn1\nyarn3 = Yarn(fiber='Polyester', color='Pitter Patter', yards=210)\nyarn4 = Yarn(fiber='Polyester', color='Vanilla', yards=70)\n\n# Perform the equality tests\nassert yarn1 == yarn2\nassert yarn1 is yarn2\nassert id(yarn1) == id(yarn2)\n\nassert yarn2 == yarn3\nassert yarn2 is not yarn3\nassert id(yarn2) != id(yarn3)\n\nassert yarn3 != yarn4\nassert yarn3 is not yarn4\nassert id(yarn3) != id(yarn4)\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Bash"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Bash",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=bash&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Bash",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is an outlier in the sense that it's an ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/feb-22-2019-bash-scripting#bash-file-basics"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"untyped language",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". All variables in bash are plain text that can be interpreted differently depending on the context. Bash provides a couple operators for determining equality of plain text.  All these operators test value equality.  There is no way that I know of to test reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"=",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operators test for plain text equality.  The ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"-eq",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator tests for integer equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Bash"
        },
        "value":"\n# In Bash everything is plain text except in certain contexts.  Both == and = test for text equality.\n# = is defined in the POSIX spec while == is Bash specific.\n[ \"andy\" = \"andy\" ] # true\n\n# = and == are synonyms\n[ \"jarombek\" == \"jarombek\" ] # true\n\n# -eq tests for equality between numbers\n[ 2 -eq 2 ] # true\n\n# This would throw an exception - integer expression expected.\n# [ \"andy\" -eq \"andy\" ] # true\n\n# Both == and = work for integers, but -eq doesn't work for strings\n[ 2 != 3 ] # true\n\n# The double parentheses construct $(( )) is used to perform arithmetic.\n# These four comparisons throw errors.\n# ((24 -eq 24))\n# ((24 = 24))\n# ((\"andy\" -eq \"andy\"))\n# ((\"andy\" = \"andy\"))\n\n((24 == 24)) # true\n\n# Using strings with double parentheses compile but aren't evaluated properly.\n# This is determined to be true, although it should be false.\n((\"Greenwich,CT\" != \"greenwich,connecticut\")) # true\n\n# ... Unless if the strings are convertible to integers.\n((\"10\" == \"10\" && \"5\" != \"6\")) # true\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" You can also easily test arrays for value equality in Bash: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Bash"
        },
        "value":"todays_workouts=(\"run\" \"walk\" \"kayak\")\ntomorrows_workouts=(\"run\" \"walk\")\nmondays_workouts=(\"run\" \"walk\" \"kayak\")\n\n# array[@] and array[*] both retrieve all the items in the array.\nday1=${todays_workouts[@]}\nday2=${tomorrows_workouts[@]}\nday3=${mondays_workouts[*]}\n\n# [[ conditions ]] has some extended features over [ conditions ], including the use of two\n# conditions separated by an && operator.\n[[ \"${day1}\" != \"${day2}\" && \"${day1}\" == \"${day3}\" ]] # true\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"C"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"C",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=c&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"C",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" has a single ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator for testing type equality.  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" can be used to test integer, floating point, and pointer types for equality.  Integer and floating point equality operations test for value equality.  Pointer equality operations test for reference equality.  C is strongly typed, so no type coercion occurs during these equality tests. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" One of the small differences between the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator in C and other languages is that in C it returns a number instead of a boolean value.  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" returns ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"1",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" when the two items are equal and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"0",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" when they aren't. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C"
        },
        "value":"int two = 2;\nint twoAgain = 2;\n\nint twosAreEqual = two == twoAgain;\n\nassert(two == twoAgain);\nassert(twosAreEqual == 1);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" As I mentioned, comparing two pointers with the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator tests for reference equality.  Similar to other languages, C caches string literals so they point to the same memory location.  This is proven in the following code: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C"
        },
        "value":"char* name = \"Andy\";\nchar* nameAgain = \"Andy\";\nchar* lastName = \"Jarombek\";\n\nassert(name == nameAgain);\nassert(name != lastName);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Strings in C can be represented as character pointers (",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"char*",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":") or character arrays.  Since character arrays always claim a new slice of memory, reference equality will fail when comparing them to a character pointer. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C"
        },
        "value":"char nameArray[] = \"Andy\";\n\nassert(name != nameArray);\nassert(nameAgain != nameArray);\nassert(nameArray != lastName);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" C is an imperative programming language and doesn't support classes or objects.  The basic construct it does support is structs.  Unfortunately the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator doesn't work with structs.  If you try using it a compile time error will occur.  To test struts for value equality, each item in the struct must be checked for equality individually.  There is also a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"memcmp()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" function available to test structs for value equality, however it isn't always reliable",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"5,6",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  To test structs for reference equality, you just need to compare the pointers to the structs. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C"
        },
        "value":"typedef struct Yarn {\n  char* fiber;\n  char* color;\n  int yards;\n} Yarn;\n\n/**\n * Determine if two Yarn structs have equal values.\n * @param y1 The first Yarn struct to compare.\n * @param y2 The second Yarn struct to compare.\n * @return 1 if the two Yarn structs are equal, 0 otherwise.\n */\nint yarnEqual(Yarn* y1, Yarn* y2) {\n  return y1->fiber == y2->fiber\n    && y1->color == y2->color\n    && y1->yards == y2->yards;\n}\n\nint main() {\n  Yarn yarn1 = {\"Polyester\", \"Pitter Patter\", 210};\n  Yarn* yarn2 = &yarn1;\n  Yarn yarn3 = {\"Polyester\", \"Pitter Patter\", 210};\n  Yarn yarn4 = {\"Polyester\", \"Vanilla\", 70};\n\n  // The == and != operators can't be used on structs.\n  // assert(yarn1 == yarn2);\n\n  // To compare them for value equality, each field in the struct must be compared explicitly.\n  assert(yarnEqual(&yarn1, yarn2));\n  assert(yarnEqual(yarn2, &yarn3));\n  assert(!yarnEqual(&yarn3, &yarn4));\n\n  // To compare them for reference equality, convert the structs to pointers and then use ==.\n  // NOTE: yarn2 is already a pointer type.\n  assert(&yarn1 == yarn2);\n  assert(yarn2 != &yarn3);\n  assert(&yarn3 != &yarn4);\n\n  // It's also said that while memcmp() often works when comparing structs for value equality,\n  // it should not be trusted.  memcmp() returns 0 if all the bytes of memory\n  // for the structs are equal, another number otherwise.\n  int yarn1EqualsYarn2 = memcmp(&yarn1, yarn2, sizeof(Yarn)) == 0;\n  int yarn2EqualsYarn3 = memcmp(yarn2, &yarn3, sizeof(Yarn)) == 0;\n  int yarn3EqualsYarn4 = memcmp(&yarn3, &yarn4, sizeof(Yarn)) == 0;\n\n  assert(yarn1EqualsYarn2);\n  assert(yarn2EqualsYarn3);\n  assert(!yarn3EqualsYarn4);\n}\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"C++"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"C++",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Similar to C, ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=c++&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"C++",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" has a single ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator for testing type equality.  However, C++ is an object-oriented language that allows for operator overloading.  Because of this, all structs and classes can use the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator with their own custom logic for value equality.  Pointer types are still used for reference equality just like C. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C++"
        },
        "value":"typedef struct Yarn {\n  string fiber;\n  string color;\n  int yards;\n\n  /**\n   * Overload the == operator to test value equality between two Yarn structs.\n   * @param other Another Yarn struct to test equality with.\n   * @return true if the two Yarn structs have equal values, false otherwise.\n   */\n  bool operator == (Yarn& other) {\n    return fiber == other.fiber\n      && color == other.color\n      && yards == other.yards;\n  }\n\n  /**\n   * Overload the != operator to test value inequality between two Yarn structs.\n   * @param other Another Yarn struct to test equality with.\n   * @return true if the two Yarn structs DON'T have equal values, false otherwise.\n   */\n  bool operator != (Yarn& other) {\n    return !(*this == other);\n  }\n\n} Yarn;\n\nint main() {\n  // Similar to C, there is no == operator for structs by default.  Unlike C, in C++ the == operator can be\n  // overloaded to work with two structs of the same type.\n  Yarn yarn1 = {\"Polyester\", \"Pitter Patter\", 210};\n  Yarn& yarn2 = yarn1;\n  Yarn yarn3 = {\"Polyester\", \"Pitter Patter\", 210};\n  Yarn yarn4 = {\"Polyester\", \"Vanilla\", 70};\n\n  // Use == and != to test the structs for value equality.\n  assert(yarn1 == yarn2);\n  assert(yarn2 == yarn3);\n  assert(yarn3 != yarn4);\n\n  // Use == and != on the pointers of the structs to test for reference equality.\n  assert(&yarn1 == &yarn2);\n  assert(&yarn2 != &yarn3);\n  assert(&yarn3 != &yarn4);\n}\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" You can see an example of equality between objects in C++ on ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\njarombek-com-sources/tree/master/2019/08-Aug/08-18-type-equality/cpp"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"GitHub",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Also the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator in C++ returns a boolean type instead of an integer type as it does in C. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C++"
        },
        "value":"int two = 2;\nint twoAgain = 2;\n\n// 'auto' can be replaced with 'bool'\nauto twosAreEqual = two == twoAgain;\n\nassert(two == twoAgain);\ncout << typeid(twosAreEqual).name() << endl; // 'b' for boolean\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"C#"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"C#",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=c#&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"C#",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" provides an ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator, an ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method, and a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"ReferenceEquals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method for testing equality.  When working with primitives, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" test for value equality.  C# is strongly typed so there is no type coercion when testing for equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" C# is often compared to Java due to similarities in their structure.  However, there are some differences when it comes to equality.  While Java primitives can't use the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method, C# primitives can.  This is because primitives in C# are aliases for structs. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C#"
        },
        "value":"int one = 1;\nint two = 2;\nAssert(one != two);\nAssert(!one.Equals(two));\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" When working with custom structs or classes, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests for value equality and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"ReferenceEquals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests for reference equality. The ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator is a trickier situation in C#.  Unlike Java, C# permits operator overloading.  This means a class designer can decide if they want to overload ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" or not.  Depending on this decision, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" may test for value equality or reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" For example, the built in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Uri",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" class overloads the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator so that it tests for value equality.  I also created a custom ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Yarn",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" class which doesn't overload ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" so that it maintains reference equality. The consequences can be seen below: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"C#"
        },
        "value":"Uri jarombekCom = new Uri(\"https://jarombek.com\");\nUri jarombekCom2 = new Uri(\"https://jarombek.com\");\n\n// If this was reference equality, it would return false.\nAssert(jarombekCom == jarombekCom2);\n\nYarn pinkYarn = new Yarn(210, Yarn.YarnWeight.SuperBulky);\nYarn multiColorYarn = new Yarn(70, Yarn.YarnWeight.Bulky);\nYarn anotherPinkYarn = new Yarn(210, Yarn.YarnWeight.SuperBulky);\n\nAssert(pinkYarn.Equals(anotherPinkYarn));\nAssert(pinkYarn != anotherPinkYarn); // == still maintains reference equality\nAssert(!pinkYarn.Equals(multiColorYarn));\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Luckily you can still use the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"ReferenceEquals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" method in case the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator is overloaded.  If you want to see more examples of equality in C#, check out my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/jarombek-com-sources/tree/master/2019/\n08-Aug/08-18-type-equality/csharp/equality"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"GitHub",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" page. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Groovy"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Groovy",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=groovy&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Groovy",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" takes Java's type equality system and makes some major changes to it.  Groovy uses ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" to test for value equality for all values.  This is different than Java which uses ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" for reference equality with value types.  You can still use ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Object.equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" in Groovy, however it will provide the same result as ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Because both ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Object.equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" are used for value equality, Groovy introduced a new method ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Object.is()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" to test for reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Groovy"
        },
        "value":"/**\n * Class representing a ball of yarn.  Through its AST annotations, Yarn has a constructor to pass in properties\n * through and functional equals() and hashCode() methods.\n */\n@TupleConstructor\n@EqualsAndHashCode\nclass Yarn {\n  String fiber\n  String color\n  int yards\n}\n\ndef firstYarnRoll = [\"Polyester\", \"Pitter Patter\", 70] as Yarn\ndef secondYarnRoll = [\"Polyester\", \"Pitter Patter\", 70] as Yarn\n\n// Groovy uses == to check for value equality, unlike Java which uses equals().  In Java,\n// only primitives use == to test value equality.\nassert firstYarnRoll == secondYarnRoll\n\n// You can still use equals() and get the same result as ==.\nassert firstYarnRoll.equals(secondYarnRoll)\n\n// Since == tests value equality, Groovy needed another way to test reference equality.  The GDK added an is() method\n// to the class Object to fulfill this purpose.\nassert !firstYarnRoll.is(secondYarnRoll)\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Like Java, Groovy is a strongly typed language.  However, there is some type coercion that occurs when comparing numeric values. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Groovy"
        },
        "value":"// == coerces different numeric types before comparing\nassert 2.0f == 2.0\nassert 2.0 == 2\nassert 2l == 2\nassert 1G == 1\n\n// ... but it doesn't coerce other types before comparing\nassert \"2.0\" != 2.0\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" If you want to see how to alter Groovy's value equality mechanism, check out the full code on ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/\nAJarombek/jarombek-com-sources/tree/master/2019/08-Aug/08-18-type-equality/groovy"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"GitHub",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Haskell"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Haskell",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=haskell&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Haskell",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is a functional programming language that behaves much differently than the other languages I'm looking at today.  It doesn't have reference equality by default, mostly for performance reasons",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"7",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  However, you can implement value equality by making a type an instance of the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Eq",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" type class. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Haskell"
        },
        "value":"\n-- The type class 'Eq' defines two functions - (==) and (/=).  (/=) has a default definition in the type class, so\n-- instances don't need to override it.  Haskell provides a shortcut for making a type an instance of the Eq type class\n-- with the 'deriving' keyword.  deriving also works for Ord, Show and Read.\ndata Yarn = Yarn String String Int\n              deriving Eq\n\n-- My custom WrappingPaper type doesn't use the 'deriving Eq' shortcut, instead explicitly making WrappingPaper\n-- an instance of Eq.\ndata WrappingPaper = WrappingPaper String String\n\ninstance Eq WrappingPaper where\n  WrappingPaper brand1 pattern1 == WrappingPaper brand2 pattern2 = brand1 == brand2 && pattern1 == pattern2\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Once ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Eq",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is implemented, the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"/=",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operators can be used.  Note that Haskell is strongly typed, so no type coercion occurs. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Haskell"
        },
        "value":"main :: IO ()\nmain = do\n  -- The following equality checks all print 'True'\n  print $ 2 == 2\n  print $ 2.2 /= 2.0\n  print $ \"andy\" == \"andy\"\n  print $ Just 4 /= Nothing\n  print $ Just [1,2] == Just [1,2]\n  print $ [\"deer\", \"chipmunk\", \"squirrel\"] == [\"deer\", \"chipmunk\", \"squirrel\"]\n\n  -- Testing the custom Yarn type which is an instance of the Eq type class.\n  let yarn1 = Yarn \"Polyester\" \"Pitter Patter\" 70\n  let yarn2 = Yarn \"Polyester\" \"Pitter Patter\" 70\n  let yarn3 = Yarn \"Polyester\" \"Vanilla\" 220\n  print $ yarn1 == yarn2\n  print $ yarn1 /= yarn3\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"PHP"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"PHP",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=php&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"PHP",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" behaves similarly to JavaScript when it comes to type equality.  PHP is a loosely typed language that provides two operators for testing equality between types.  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests value equality with coercion for primitive types and tests value equality without coercion for objects.  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"===",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests value equality without coercion for primitive types and tests reference equality for objects.  Here are some examples of primitive type equality checks: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"PHP"
        },
        "value":"assert(2 == '2');\nassert(\"2\" == 2);\nassert(2 == 2);\nassert(true == \"1\");\nassert(false == \"0\");\n\n// Just like JavaScript, implicit type coercion can cause strange behavior\nassert(\"00\" == \"0000\");\nassert(null == array());\n\n// However, you could say it's not \"as\" loosely typed as JavaScript.  In JavaScript, [10] == 10 returns true.\nassert([10] != 10);\n\n// Just like JavaScript, === disallows type coercion.\nassert(2 === 2);\nassert(2 !== \"2\");\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Now here is a custom class I created for testing value and reference equality with objects. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"PHP"
        },
        "value":"class Yarn\n{\n  private $fiber;\n  private $color;\n  private $yards;\n\n  /**\n   * Yarn constructor that accepts all necessary fields.\n   * @param $fiber - The fiber that the yarn is made of.\n   * @param $color - The visual color of the yarn.\n   * @param $yards - The length of the yarn in yards.\n   */\n  public function __construct($fiber, $color, $yards)\n  {\n    $this->fiber = $fiber;\n    $this->color = $color;\n    $this->yards = $yards;\n  }\n}\n\n// When testing equality of objects, == tests for value equality and === tests for reference equality.  These operators\n// work without any explicit definitions and without operator overloading.\n$yarn1 = new Yarn(\"Polyester\", \"Pitter Patter\", 210);\n$yarn2 = $yarn1;\n$yarn3 = new Yarn(\"Polyester\", \"Pitter Patter\", 210);\n$yarn4 = new Yarn(\"Polyester\", \"Vanilla\", 70);\n\nassert($yarn1 == $yarn2);\nassert($yarn1 === $yarn2);\n\nassert($yarn2 == $yarn3);\nassert($yarn2 !== $yarn3);\n\nassert($yarn3 != $yarn4);\nassert($yarn3 !== $yarn4);\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"PowerShell"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"PowerShell",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=powershell&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"PowerShell",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is a loosely typed scripting language.  It has a native operator ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"-eq",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" for testing value equality. One of the cool things about PowerShell is that is has full access to the .NET Framework, including the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"[System.Object]::Equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"[System.Object]::ReferenceEquals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" functions I explored earlier in C#. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" When testing primitive values for value equality, the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"-eq",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator (and opposite ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"-ne",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator) work as expected for a loosely typed language: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"PowerShell"
        },
        "value":"[int] $two = 2;\n[int] $twoAgain = 2;\n\nTest-Assertion($two -eq $twoAgain)\nTest-Assertion($two -eq \"2\")\n\nTest-Assertion($two -ne 3)\nTest-Assertion($two -ne \"3\")\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" When working with objects in PowerShell, the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"-eq",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"[System.Object]::Equals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" function are used to test value equality. The ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"[System.Object]::ReferenceEquals()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" function is used to test reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"PowerShell"
        },
        "value":"class Yarn {\n  <#\n  .SYNOPSIS\n  Class representing a ball of yarn for knitting.\n  #>\n\n  [string] $fiber;\n  [string] $color;\n  [int] $yards;\n\n  Yarn ([string] $fiber, [string] $color, [int] $yards) {\n    <#\n    .SYNOPSIS\n    Construct a new instance of Yarn with values for all the fields.\n    #>\n    $this.fiber = $fiber;\n    $this.color = $color;\n    $this.yards = $yards;\n  }\n\n  [bool] Equals([System.Object] $other) {\n    <#\n    .SYNOPSIS\n    Determine if the value of two Yarn objects are equal.\n    #>\n    [bool] $fibersEqual = $this.fiber -eq $other.fiber\n    [bool] $colorsEqual = $this.color -eq $other.color\n    [bool] $yardsEqual = $this.yards -eq $other.yards\n    return $fibersEqual -and $colorsEqual -and $yardsEqual;\n  }\n}\n\n# Create instances of the custom Yarn class for comparison.\n$yarn1 = [Yarn]::new(\"Polyester\", \"Pitter Patter\", 210);\n$yarn2 = $yarn1;\n$yarn3 = [Yarn]::new(\"Polyester\", \"Pitter Patter\", 210);\n$yarn4 = [Yarn]::new(\"Polyester\", \"Vanilla\", 70);\n\n# Test the Yarn objects for reference and value equality.\nTest-Assertion([System.Object]::Equals($yarn1, $yarn2))\nTest-Assertion($yarn1 -eq $yarn2)\nTest-Assertion([System.Object]::ReferenceEquals($yarn1, $yarn2))\n\nTest-Assertion([System.Object]::Equals($yarn2, $yarn3))\nTest-Assertion($yarn2 -eq $yarn3)\nTest-Assertion(-not [System.Object]::ReferenceEquals($yarn2, $yarn3))\n\nTest-Assertion(-not [System.Object]::Equals($yarn3, $yarn4))\nTest-Assertion($yarn3 -ne $yarn4)\nTest-Assertion(-not [System.Object]::ReferenceEquals($yarn3, $yarn4))\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Swift"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Swift",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=swift&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Swift",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" provides two operators to test equality. For value types and structs, the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator tests for value equality. There is no way to test for reference equality on value types or structs.  For objects, the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator tests for value equality and the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"===",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator tests for reference equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The following examples demonstrate how to test equality amongst value types. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Swift"
        },
        "value":"let name: String = \"Andy\"\nlet nameAgain: String = \"Andy\"\n\nassert(name == nameAgain)\n\n// The value types in Swift are String, Int, Float, Double, Array, and Dictionary.\nlet animals: [String:String] = [\"Dotty\":\"Horse\", \"Lily\":\"Bear\"]\nlet animalsAgain: [String:String] = [\"Dotty\":\"Horse\", \"Lily\":\"Bear\"]\n\nassert(animals == animalsAgain)\n\n// Value equality also works with the Objective-C String equivalent in Swift\nlet lastName: NSString = \"Jarombek\"\nlet lastNameAgain: NSString = \"Jarombek\"\n\nassert(lastName == lastNameAgain)\n\n// You can't perform reference equality on value types in Swift.  Reference equality is tested\n// with the === operator.  The following examples will not compile with this note attached:\n// expected an argument list of type '(AnyObject?, AnyObject?)'\n\n// var valueTypesReferencesEqual: Bool = name === nameAgain\n// var valueTypesReferencesEqual: Bool = animals === animalsAgain\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The next piece of code creates a custom struct and a custom class.  Both demonstrate how the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"===",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operators work. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Swift"
        },
        "value":"struct Yarn: Equatable {\n  let fiber: String\n  let color: String\n  let yards: Int\n\n  /**\n  Function from the equatable protocol to overload the == operator when comparing yarn objects.\n  - parameters:\n  - lhs: the first ball of yarn to test for equality.\n  - rhs: the second ball of yarn to test for equality.\n  - returns: true if the properties in both the yarn structs are equal, false otherwise.\n  */\n  static func ==(lhs: Yarn, rhs: Yarn) -> Bool {\n    return (lhs.fiber == rhs.fiber) && (lhs.color == rhs.color) && (lhs.yards == rhs.yards)\n  }\n}\n\nlet firstYarnBall: Yarn = Yarn(fiber: \"Polyester\", color: \"Pitter Patter\", yards: 210)\nlet secondYarnBall: Yarn = firstYarnBall\nlet thirdYarnBall: Yarn = Yarn(fiber: \"Polyester\", color: \"Pitter Patter\", yards: 210)\nlet fourthYarnBall: Yarn = Yarn(fiber: \"Polyester\", color: \"Vanilla\", yards: 70)\n\n// Since Yarn is a struct and not a class, reference equality doesn't work.  Remember that the\n// arguments to ==(lhs, rhs) must be of type AnyObject?\n// assert(firstYarnBall === secondYarnBall)\n\nassert(firstYarnBall == secondYarnBall)\nassert(secondYarnBall == thirdYarnBall)\nassert(thirdYarnBall != fourthYarnBall)\n\nclass WrappingPaper: Equatable {\n  let brand: String\n  let pattern: String\n\n  init(brand: String, pattern: String) {\n    self.brand = brand\n    self.pattern = pattern\n  }\n\n  /**\n  Function from the equatable protocol to overload the == operator when comparing wrapping gift objects.\n  - parameters:\n  - lhs: the first wrapping paper object to test for equality.\n  - rhs: the second wrapping paper object to test for equality.\n  - returns: true if the properties in both the wrapping paper objects are equal, false otherwise.\n  */\n  static func ==(lhs: WrappingPaper, rhs: WrappingPaper) -> Bool {\n    return (lhs.brand == rhs.brand) && (lhs.pattern == rhs.pattern)\n  }\n}\n\nlet firstWrappingPaper: WrappingPaper = WrappingPaper(brand: \"Hallmark\", pattern: \"Disney Princess\")\nlet secondWrappingPaper: WrappingPaper = firstWrappingPaper\nlet thirdWrappingPaper: WrappingPaper = WrappingPaper(brand: \"Hallmark\", pattern: \"Disney Princess\")\nlet fourthWrappingPaper: WrappingPaper = WrappingPaper(brand: \"Unknown\", pattern: \"None\")\n\n// Since WrappingPaper is a class, objects of type WrappingPaper can use the reference equality operator ===.\n// This is because both objects are of type AnyObject?\nassert(firstWrappingPaper === secondWrappingPaper)\nassert(secondWrappingPaper !== thirdWrappingPaper)\nassert(thirdWrappingPaper !== fourthWrappingPaper)\n\n// Since WrappingPaper implements the Equatable protocol, it can also use value equality.\nassert(firstWrappingPaper == secondWrappingPaper)\nassert(secondWrappingPaper == thirdWrappingPaper)\nassert(thirdWrappingPaper != fourthWrappingPaper)\n",
        "children":null
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"TypeScript"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"TypeScript",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog?query=typescript&page=1"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"TypeScript",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" takes JavaScripts type equality system and adds restrictions to it.  The reason for this is to try and protect JavaScript programmers from making mistakes with type coercion.  You could say that TypeScript is more strongly typed than JavaScript. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" If you try using the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"==",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" operator on two different types, TypeScript will throw a compile time error: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"TypeScript"
        },
        "value":"\n// This code is valid in JavaScript but won't compile in TypeScript.  TypeScript doesn't allow for\n// values of guaranteed different types to be compared with == or ===.\n// TS2365: Operator == cant be applied to types '2' and \"2\".\nassert(2 == \"2\");\nassert(2 !== \"2\");\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" You can however trick TypeScript into thinking the two values are of comparable types by using the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"any",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" or ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "class":"jarombek-inline-code"
                },
                "value":"Object",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" types: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"TypeScript"
        },
        "value":"\n// Since TypeScript compiles to JavaScript, we can trick TypeScript about the compile-time types of\n// mismatching types.  This allows for == and === to compile for unequal types.\n\n// == works the same in TypeScript as in JavaScript if the compile time type of a string or number\n// being compared is 'any' or 'Object'.\nconst age: number = 24;\nconst ageStr: any = \"24\";\nconst ageObj: Object = \"24\";\n\n// This assertion compiles and succeeds thanks to JavaScript type coercion.\nassert(age == ageStr);\n\nassert(age !== ageStr);\nassert(age == ageObj);\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Besides for this additional type safety, equality in TypeScript is the same as JavaScript. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Conclusions"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Conclusions",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" I had a lot of fun switching between languages and re-exploring type equality.  You can find the source code for this article on ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/jarombek-com-sources/tree/master/2019/08-Aug/\n08-18-type-equality"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"GitHub",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    }
];

postName = "aug-18-2019-type-equality";
postDate = new Date('2019-08-18T12:00:00');
existingPost = db.posts.findOne({name: postName});

postViews = (existingPost) ? existingPost.views : 0;

db.posts.remove({name: postName});
db.posts_content.remove({name: postName});

db.posts.insertOne({
    name: postName,
    title: "Revisiting Type Equality",
    description: `In my time spent re-learning type equality in 13 different languages I’ve 
        reaffirmed my knowledge and gained new insights.  The rest of the article discusses my 
        findings.`,
    date: postDate,
    type: "Discovery",
    views: postViews,
    tags: [
        {
            name: "Java",
            picture: "https://asset.jarombek.com/logos/java.png",
            color: "java"
        },
        {
            name: "JavaScript",
            picture: "https://asset.jarombek.com/logos/js.png",
            color: "javascript"
        },
        {
            name: "Python",
            picture: "https://asset.jarombek.com/logos/python.png",
            color: "python"
        },
        {
            name: "Bash",
            picture: "https://asset.jarombek.com/logos/bash.png",
            color: "bash"
        },
        {
            name: "C",
            picture: "https://asset.jarombek.com/logos/c.png",
            color: "c"
        },
        {
            name: "C++",
            picture: "https://asset.jarombek.com/logos/cpp.png",
            color: "cpp"
        },
        {
            name: "C#",
            picture: "https://asset.jarombek.com/logos/csharp.png",
            color: "csharp"
        },
        {
            name: "Groovy",
            picture: "https://asset.jarombek.com/logos/groovy.png",
            color: "groovy"
        },
        {
            name: "Haskell",
            picture: "https://asset.jarombek.com/logos/haskell.png",
            color: "haskell"
        },
        {
            name: "PHP",
            picture: "https://asset.jarombek.com/logos/php.svg",
            color: "php"
        },
        {
            name: "PowerShell",
            picture: "https://asset.jarombek.com/logos/powershell.png",
            color: "powershell"
        },
        {
            name: "Swift",
            picture: "https://asset.jarombek.com/logos/swift.png",
            color: "swift"
        },
        {
            name: "TypeScript",
            picture: "https://asset.jarombek.com/logos/ts.png",
            color: "typescript"
        },
        {
            name: "Object Oriented Programming"
        },
        {
            name: "Imperative Programming"
        },
        {
            name: "Functional Programming"
        },
        {
            name: "Command Line Scripting"
        }
    ],
    preview,
    previewString: JSON.stringify(preview),
    sources: [
        {
            startName: "Kyle Simpson, ",
            endName: " (Beijing: O'Reilly, 2014), 1",
            linkName: "You Don't Know JavaScript: Types & Grammar",
            link: "https://github.com/getify/You-Dont-Know-JS/tree/master/types%20%26%20grammar"
        },
        {
            startName: "\"how equal operator works with primitive and object type data\", ",
            endName: "",
            linkName: "https://stackoverflow.com/a/29139595",
            link: "https://stackoverflow.com/a/29139595"
        },
        {
            startName: "\"Object Equality in JavaScript\", ",
            endName: "",
            linkName: "http://adripofjavascript.com/blog/drips/object-equality-in-javascript.html",
            link: "http://adripofjavascript.com/blog/drips/object-equality-in-javascript.html"
        },
        {
            startName: "\"How to check if two arrays are equal with vanilla JS\", ",
            endName: "",
            linkName: "https://gomakethings.com/how-to-check-if-two-arrays-are-equal-with-vanilla-js/",
            link: "https://gomakethings.com/how-to-check-if-two-arrays-are-equal-with-vanilla-js/"
        },
        {
            startName: "\"How do you compare structs for equality in C?\", ",
            endName: "",
            linkName: "https://stackoverflow.com/q/141720",
            link: "https://stackoverflow.com/q/141720"
        },
        {
            startName: "\"memcmp\", ",
            endName: "",
            linkName: "http://www.cplusplus.com/reference/cstring/memcmp/",
            link: "http://www.cplusplus.com/reference/cstring/memcmp/"
        },
        {
            startName: "\"r/haskell: Why no reference equality?\", ",
            endName: "",
            linkName: "https://www.reddit.com/r/haskell/comments/4ivvge/why_no_reference_equality/",
            link: "https://www.reddit.com/r/haskell/comments/4ivvge/why_no_reference_equality/"
        }
    ]
});

db.posts_content.insertOne({
    name: postName,
    date: postDate,
    content,
    contentString: JSON.stringify(content)
});